<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · Sinograms.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaImageRecon.github.io/Sinograms.jl/stable/methods/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Sinograms.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Sinograms.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Methods-list"><span>Methods list</span></a></li><li><a class="tocitem" href="#Methods-usage"><span>Methods usage</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/01-tomography/">Tomography overview</a></li><li><a class="tocitem" href="../generated/examples/02-sino-geom/">2D sinogram geometry</a></li><li><a class="tocitem" href="../generated/examples/03-parallel-beam/">Parallel-beam tomography</a></li><li><a class="tocitem" href="../generated/examples/04-fan-arc/">Fan-beam tomography: arc detector</a></li><li><a class="tocitem" href="../generated/examples/05-fan-flat/">Fan-beam tomography: flat detector</a></li><li><a class="tocitem" href="../generated/examples/06-fan-short/">Fan-beam tomography: short scan</a></li><li><a class="tocitem" href="../generated/examples/07-fdk/">CBCT FDK</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/main/docs/src/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Methods-list"><a class="docs-heading-anchor" href="#Methods-list">Methods list</a><a id="Methods-list-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-list" title="Permalink"></a></h2><ul><li><a href="#Sinograms.Sinograms"><code>Sinograms.Sinograms</code></a></li><li><a href="#Sinograms.CtFanArc-Tuple{Val{:ge1}}"><code>Sinograms.CtFanArc</code></a></li><li><a href="#Sinograms.CtFanArc"><code>Sinograms.CtFanArc</code></a></li><li><a href="#Sinograms.CtFanArc-Tuple{}"><code>Sinograms.CtFanArc</code></a></li><li><a href="#Sinograms.CtFanFlat-Tuple{}"><code>Sinograms.CtFanFlat</code></a></li><li><a href="#Sinograms.CtFanFlat"><code>Sinograms.CtFanFlat</code></a></li><li><a href="#Sinograms.CtGeom"><code>Sinograms.CtGeom</code></a></li><li><a href="#Sinograms.CtPar-Tuple{}"><code>Sinograms.CtPar</code></a></li><li><a href="#Sinograms.CtPar"><code>Sinograms.CtPar</code></a></li><li><a href="#Sinograms.CtSource"><code>Sinograms.CtSource</code></a></li><li><a href="#Sinograms.CtSourceCircle"><code>Sinograms.CtSourceCircle</code></a></li><li><a href="#Sinograms.CtSourceHelix-Tuple{}"><code>Sinograms.CtSourceHelix</code></a></li><li><a href="#Sinograms.CtSourceHelix"><code>Sinograms.CtSourceHelix</code></a></li><li><a href="#Sinograms.FBPNormalPlan"><code>Sinograms.FBPNormalPlan</code></a></li><li><a href="#Sinograms.FBPplan"><code>Sinograms.FBPplan</code></a></li><li><a href="#Sinograms.FDKplan"><code>Sinograms.FDKplan</code></a></li><li><a href="#Sinograms.RayGeom"><code>Sinograms.RayGeom</code></a></li><li><a href="#Sinograms.SinoFanArc-Tuple{}"><code>Sinograms.SinoFanArc</code></a></li><li><a href="#Sinograms.SinoFanArc-Tuple{Val{:ge1}}"><code>Sinograms.SinoFanArc</code></a></li><li><a href="#Sinograms.SinoFanArc"><code>Sinograms.SinoFanArc</code></a></li><li><a href="#Sinograms.SinoFanFlat"><code>Sinograms.SinoFanFlat</code></a></li><li><a href="#Sinograms.SinoFanFlat-Tuple{}"><code>Sinograms.SinoFanFlat</code></a></li><li><a href="#Sinograms.SinoGeom"><code>Sinograms.SinoGeom</code></a></li><li><a href="#Sinograms.SinoMoj"><code>Sinograms.SinoMoj</code></a></li><li><a href="#Sinograms.SinoMoj-Tuple{}"><code>Sinograms.SinoMoj</code></a></li><li><a href="#Sinograms.SinoPar-Tuple{}"><code>Sinograms.SinoPar</code></a></li><li><a href="#Sinograms.SinoPar"><code>Sinograms.SinoPar</code></a></li><li><a href="#Sinograms.Window"><code>Sinograms.Window</code></a></li><li><a href="#Sinograms.WindowVect"><code>Sinograms.WindowVect</code></a></li><li><a href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Sinograms.RayGeom}"><code>Base.show</code></a></li><li><a href="#Sinograms._angle_weights-Tuple{AbstractVector{&lt;:Number}}"><code>Sinograms._angle_weights</code></a></li><li><a href="#Sinograms._gamma"><code>Sinograms._gamma</code></a></li><li><a href="#Sinograms._reale-Tuple{Any}"><code>Sinograms._reale</code></a></li><li><a href="#Sinograms._rfov-Tuple{Union{CtPar, SinoPar}}"><code>Sinograms._rfov</code></a></li><li><a href="#Sinograms._shape-Tuple{Sinograms.RayGeom, AbstractArray}"><code>Sinograms._shape</code></a></li><li><a href="#Sinograms._show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Any}"><code>Sinograms._show</code></a></li><li><a href="#Sinograms._tau-Tuple{Sinograms.RayGeom, AbstractArray, AbstractArray}"><code>Sinograms._tau</code></a></li><li><a href="#Sinograms._unitv"><code>Sinograms._unitv</code></a></li><li><a href="#Sinograms._xds-Tuple{Union{CtPar, SinoPar}}"><code>Sinograms._xds</code></a></li><li><a href="#Sinograms._yds-Union{Tuple{Union{CtPar{Td}, SinoPar{Td}}}, Tuple{Td}} where Td"><code>Sinograms._yds</code></a></li><li><a href="#Sinograms.angles-Tuple{Sinograms.RayGeom}"><code>Sinograms.angles</code></a></li><li><a href="#Sinograms.cb_arc_to_par-Union{Tuple{Ts}, Tuple{Ts, Number, Number, Number, Number}} where Ts&lt;:Number"><code>Sinograms.cb_arc_to_par</code></a></li><li><a href="#Sinograms.cb_flat_to_par-NTuple{5, Number}"><code>Sinograms.cb_flat_to_par</code></a></li><li><a href="#Sinograms.cbct_back-Tuple{AbstractArray{&lt;:Number, 3}, CtFan, ImageGeoms.ImageGeom{3, S, M} where {S&lt;:Tuple{Number, Number, Number}, M&lt;:AbstractArray{Bool, 3}}}"><code>Sinograms.cbct_back</code></a></li><li><a href="#Sinograms.cbct_back_fan!-Union{Tuple{Toffset}, Tuple{T}, Tuple{Array{T, 3}, AbstractArray{&lt;:Number, 3}, AbstractVector{&lt;:Number}, Number, Number, Number, Number, Toffset, Toffset, Bool, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractArray{Bool, 3}}} where {T&lt;:Number, Toffset&lt;:Real}"><code>Sinograms.cbct_back_fan!</code></a></li><li><a href="#Sinograms.ct_geom_plot2!-Tuple{CtGeom, ImageGeoms.ImageGeom}"><code>Sinograms.ct_geom_plot2!</code></a></li><li><a href="#Sinograms.ct_geom_plot3-Tuple{CtFan, ImageGeoms.ImageGeom}"><code>Sinograms.ct_geom_plot3</code></a></li><li><a href="#Sinograms.downsample-Union{Tuple{G}, Tuple{G, Int64}} where G&lt;:SinoParallel"><code>Sinograms.downsample</code></a></li><li><a href="#Sinograms.downsample-Tuple{CtGeom, Int64}"><code>Sinograms.downsample</code></a></li><li><a href="#Sinograms.fbp-Union{Tuple{AbstractMatrix{Ts}}, Tuple{Td}, Tuple{Ts}} where {Ts&lt;:Number, Td&lt;:Number}"><code>Sinograms.fbp</code></a></li><li><a href="#Sinograms.fbp"><code>Sinograms.fbp</code></a></li><li><a href="#Sinograms.fbp!-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><code>Sinograms.fbp!</code></a></li><li><a href="#Sinograms.fbp_back"><code>Sinograms.fbp_back</code></a></li><li><a href="#Sinograms.fbp_back_fan-Union{Tuple{Tc}, Tuple{Toffset}, Tuple{Tds}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, Number, Number, Number, Bool, Tds, Toffset, AbstractArray{Tc}, AbstractArray{Tc}, AbstractMatrix{Bool}}} where {Ts&lt;:Number, To&lt;:Number, Tds&lt;:Number, Toffset&lt;:Real, Tc&lt;:Number}"><code>Sinograms.fbp_back_fan</code></a></li><li><a href="#Sinograms.fbp_back_fan!-Union{Tuple{Toffset}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Number, Number, Number, Bool, Number, Toffset, AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}, AbstractMatrix{Bool}}} where {T&lt;:Number, Toffset&lt;:Real}"><code>Sinograms.fbp_back_fan!</code></a></li><li><a href="#Sinograms.fbp_back_fan_xy-Union{Tuple{Tx}, Tuple{Tb}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, AbstractVector{To}, Real, Real, Real, Bool, Tb, Tx, Tx}} where {Ts&lt;:Number, To&lt;:Real, Tb&lt;:Real, Tx&lt;:Real}"><code>Sinograms.fbp_back_fan_xy</code></a></li><li><a href="#Sinograms.fbp_back_par-Union{Tuple{Tc}, Tuple{Toffset}, Tuple{Tds}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, Tds, Toffset, AbstractArray{Tc}, AbstractArray{Tc}, AbstractMatrix{Bool}}} where {Ts&lt;:Number, To&lt;:Number, Tds&lt;:Number, Toffset&lt;:Real, Tc&lt;:Number}"><code>Sinograms.fbp_back_par</code></a></li><li><a href="#Sinograms.fbp_back_par!-Union{Tuple{Toffset}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Number, Toffset, AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}, AbstractMatrix{Bool}}} where {T&lt;:Number, Toffset&lt;:Real}"><code>Sinograms.fbp_back_par!</code></a></li><li><a href="#Sinograms.fbp_back_par_xy-Union{Tuple{Tx}, Tuple{Tb}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, AbstractVector{To}, Tb, Tx, Tx}} where {Ts&lt;:Number, To&lt;:Real, Tb&lt;:Real, Tx&lt;:Real}"><code>Sinograms.fbp_back_par_xy</code></a></li><li><a href="#Sinograms.fbp_filter-Union{Tuple{}, Tuple{Sinograms.RayGeom{Td}}, Tuple{Td}} where Td&lt;:Number"><code>Sinograms.fbp_filter</code></a></li><li><a href="#Sinograms.fbp_ramp"><code>Sinograms.fbp_ramp</code></a></li><li><a href="#Sinograms.fbp_sino_filter-Union{Tuple{Ts}, Tuple{AbstractArray{Ts}, AbstractVector{&lt;:Number}}} where Ts&lt;:Number"><code>Sinograms.fbp_sino_filter</code></a></li><li><a href="#Sinograms.fbp_sino_weight-Tuple{SinoFan}"><code>Sinograms.fbp_sino_weight</code></a></li><li><a href="#Sinograms.fbp_window-Tuple{Window, Int64}"><code>Sinograms.fbp_window</code></a></li><li><a href="#Sinograms.fdk-Tuple{FDKplan, AbstractArray{&lt;:Number, 3}}"><code>Sinograms.fdk</code></a></li><li><a href="#Sinograms.fdk_weight_cyl"><code>Sinograms.fdk_weight_cyl</code></a></li><li><a href="#Sinograms.fft_filter"><code>Sinograms.fft_filter</code></a></li><li><a href="#Sinograms.footprint_size"><code>Sinograms.footprint_size</code></a></li><li><a href="#Sinograms.oversample-Union{Tuple{G}, Tuple{G, Int64}} where G&lt;:CtParallel"><code>Sinograms.oversample</code></a></li><li><a href="#Sinograms.oversample-Union{Tuple{G}, Tuple{G, Int64}} where G&lt;:SinoParallel"><code>Sinograms.oversample</code></a></li><li><a href="#Sinograms.parker_weight"><code>Sinograms.parker_weight</code></a></li><li><a href="#Sinograms.parker_weight-Tuple{CtFan}"><code>Sinograms.parker_weight</code></a></li><li><a href="#Sinograms.plan_fbp-Tuple{CtGeom, ImageGeoms.ImageGeom}"><code>Sinograms.plan_fbp</code></a></li><li><a href="#Sinograms.plan_fbp-Tuple{SinoGeom, ImageGeoms.ImageGeom}"><code>Sinograms.plan_fbp</code></a></li><li><a href="#Sinograms.ramp_arc-Tuple{Int64, Number, Number}"><code>Sinograms.ramp_arc</code></a></li><li><a href="#Sinograms.ramp_flat-Tuple{Int64, Number}"><code>Sinograms.ramp_flat</code></a></li><li><a href="#Sinograms.rays-Tuple{SinoPar}"><code>Sinograms.rays</code></a></li><li><a href="#Sinograms.rays-Tuple{CtPar}"><code>Sinograms.rays</code></a></li><li><a href="#Sinograms.sino_geom_plot!-Tuple{SinoGeom}"><code>Sinograms.sino_geom_plot!</code></a></li><li><a href="#Sinograms.sino_geom_plot!-Tuple{SinoGeom, ImageGeoms.ImageGeom}"><code>Sinograms.sino_geom_plot!</code></a></li><li><a href="#Sinograms.sino_plot_rays-Tuple{SinoGeom}"><code>Sinograms.sino_plot_rays</code></a></li><li><a href="#Sinograms.to_radians-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Sinograms.to_radians</code></a></li><li><a href="#Sinograms.to_radians-Union{Tuple{AbstractArray{&lt;:Unitful.Quantity{T}}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Sinograms.to_radians</code></a></li><li><a href="#Sinograms.zwart_powell-Tuple{Real, Real}"><code>Sinograms.zwart_powell</code></a></li></ul><h2 id="Methods-usage"><a class="docs-heading-anchor" href="#Methods-usage">Methods usage</a><a id="Methods-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-usage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sinograms.Sinograms" href="#Sinograms.Sinograms"><code>Sinograms.Sinograms</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Sinograms module</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/Sinograms.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtFanArc" href="#Sinograms.CtFanArc"><code>Sinograms.CtFanArc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CtFanArc{Td,To,Ts}</code></pre><p>3D CBCT geometry for arc detector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type3.jl#L141-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtFanArc-Tuple{Val{:ge1}}" href="#Sinograms.CtFanArc-Tuple{Val{:ge1}}"><code>Sinograms.CtFanArc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CtFanArc(::Val{:ge1} ; kwargs...)</code></pre><p>GE Lightspeed system CT geometry.</p><p><strong>option</strong></p><ul><li><code>unit::RealU = 1</code> or use <code>1mm</code></li><li>(see <code>CtFanArc</code>)</li></ul><p><strong>out</strong></p><ul><li><code>CtFanArc</code></li></ul><p>These numbers are published in IEEE T-MI Oct. 2006, p.1272-1283 wang:06:pwl.</p><pre><code class="language-julia-repl hljs">julia&gt; CtFanArc(Val(:ge1))
CtFanArc{Float64, Float32, CtSourceCircle} :
 ns::Int64 888
 nt::Int64 64
 ds::Float64 1.0239
 dt::Float64 1.0964
 offset_s::Float32 1.25
 offset_t::Float32 0.0
 na::Int64 984
 orbit::Float32 360.0
 orbit_start::Float32 0.0
 source_offset::Float64 0.0
 dsd::Float64 949.075
 dod::Float64 408.075
 src::CtSourceCircle CtSourceCircle()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type3.jl#L412-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtFanArc-Tuple{}" href="#Sinograms.CtFanArc-Tuple{}"><code>Sinograms.CtFanArc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CtFanArc( ; ns nt ds dt offset_s offset_t
    na orbit orbit_start
    dsd = 4ns * ds, dod = ns * ds)
CtFanArc(:short ; ...)</code></pre><p>Constructor with named keywords. See <code>?CtGeom</code> for documentation.</p><ul><li>Use <code>:short</code> argument to specify a short scan, in which case <code>na</code> will be scaled down proportionally as well.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; CtFanArc()
CtFanArc{Float32, Float32, CtSourceCircle} :
 ns::Int64 128
 nt::Int64 64
 ds::Float32 1.0
 dt::Float32 1.0
 offset_s::Float32 0.0
 offset_t::Float32 0.0
 na::Int64 64
 orbit::Float32 360.0
 orbit_start::Float32 0.0
 source_offset::Float32 0.0
 dsd::Float32 512.0
 dod::Float32 128.0
 src::CtSourceCircle CtSourceCircle()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type3.jl#L276-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtFanFlat" href="#Sinograms.CtFanFlat"><code>Sinograms.CtFanFlat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CtFanFlat{Td,To,Ts}</code></pre><p>3D CTCT geometry for flat detector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type3.jl#L164-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtFanFlat-Tuple{}" href="#Sinograms.CtFanFlat-Tuple{}"><code>Sinograms.CtFanFlat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CtFanFlat( ; ns nt ds dt offset_s offset_t
    na orbit orbit_start
    dsd = 4ns * ds, dod = ns * ds)
CtFanFlat(:short ; ...)</code></pre><p>Constructor with named keywords. See <code>?CtGeom</code> for documentation.</p><ul><li>Use <code>:short</code> argument to specify a short scan, in which case <code>na</code> will be scaled down proportionally as well.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; CtFanFlat()
CtFanFlat{Float32, Float32, CtSourceCircle} :
 ns::Int64 128
 nt::Int64 64
 ds::Float32 1.0
 dt::Float32 1.0
 offset_s::Float32 0.0
 offset_t::Float32 0.0
 na::Int64 64
 orbit::Float32 360.0
 orbit_start::Float32 0.0
 source_offset::Float32 0.0
 dsd::Float32 512.0
 dod::Float32 128.0
 src::CtSourceCircle CtSourceCircle()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type3.jl#L344-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtGeom" href="#Sinograms.CtGeom"><code>Sinograms.CtGeom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CtGeom{Td,To,Ts}</code></pre><p>Abstract type for representing ray geometries for 3D CT imaging.</p><p>The projection view coordinates are <code>(s,t)</code> where <code>s</code> denotes the transaxial sampling and <code>t</code> denotes the axial direction (along <code>z</code>).</p><p><strong>Common fields</strong></p><ul><li><code>ns</code> size of each projection view</li><li><code>nt</code></li><li><code>ds</code> detector pixel spacing</li><li><code>dt</code></li><li><code>offset_s</code> unitless detector center offset (usually 0 or 0.25)</li><li><code>offset_t</code> unitless, usually 0</li><li><code>na</code> # of projection views, aka nϕ or nβ</li><li><code>orbit</code> source orbit in degrees (or Unitful)</li><li><code>orbit_start</code> starting angle in degrees (or Unitful) <code>orbit</code> and <code>orbit_start</code> must both be unitless (degrees) or have same units.</li><li><code>src::CtSource</code> describes the X-ray CT source trajectory. Primary support for <code>CtSourceCircle()</code>.</li></ul><p><strong>Additional fields for <code>CtFan</code> types:</strong></p><ul><li><code>dsd</code> distance from source to detector</li><li><code>dod</code> distance from origin to detector</li><li><code>source_offset</code> usually 0</li></ul><p><strong>Units:</strong></p><ul><li><code>ds</code>, <code>dt</code>, <code>source_offset</code>, <code>dsd</code>, <code>dod</code> must all be unitless or have the same units.</li></ul><p><strong>Basic methods</strong></p><ul><li><code>angles</code> (na) in degrees</li><li><code>dims (ns, nt, na)</code></li><li><code>ones = ones(Float32, ns,nt,na)</code></li><li><code>zeros = zeros(Float32, ns,nt,na)</code></li><li><code>rays</code> iterator of <code>(u,v,ϕ,θ)</code> samples</li><li><code>downsample(st, down)</code> reduce sampling by integer factor</li><li><code>oversample(st, over)</code></li><li><code>ct_geom_plot3</code> plot system geometry</li></ul><p><strong>Non-exported helper functions for developers:</strong></p><ul><li><code>_s (ns) s</code> sample locations</li><li><code>_t (nt) t</code> sample locations</li><li><code>_ws = (ns-1)/2 + offset_s</code> &quot;middle&quot; sample position</li><li><code>_wt = (nt-1)/2 + offset_t</code></li><li><code>_ar (na)</code> source angles [radians]</li><li><code>_rfov</code> max radius within FOV</li><li><code>_zfov</code> axial FOV</li><li><code>_xds (nb)</code> center of detector elements (beta=0)</li><li><code>_yds (nb)</code> &quot;&quot;</li><li><code>_tau(rg, x, y)</code> projected s/ds for each <code>(x,y)</code> pair <code>(length(x), na)</code></li><li><code>_shape(rg, proj [,:])</code> reshape <code>proj</code> into array <code>(ns,nt,na[,:])</code></li><li><code>_unitv(rg [, (is,it,ia)])</code> unit &#39;vector&#39; with single nonzero element</li></ul><p>For fan beam:</p><ul><li><code>_dso = dsd - dod</code> distance from source to origin (Inf for parallel beam)</li><li><code>_dfs</code> distance from source to detector focal spot       (0 for 3rd gen CT, <code>Inf</code> for flat detectors)</li><li><code>_gamma(rg [,s]) (ns)</code> gamma sample values <code>radians</code>, optionally given <code>s</code> values</li><li><code>_gamma_max = max(|γ|)</code> half of fan angle <code>radians</code>, if <code>offset_s</code> == 0</li><li><code>_cone_angle</code> (half) cone angle on axis (s=0): +/- angle</li></ul><p><strong>Notes</strong></p><p>Use <code>sino_geom()</code> instead for 2D geometries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type3.jl#L14-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtPar" href="#Sinograms.CtPar"><code>Sinograms.CtPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CtPar{Td,To,Ts}</code></pre><p>3D parallel-beam projection geometry</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type3.jl#L98-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtPar-Tuple{}" href="#Sinograms.CtPar-Tuple{}"><code>Sinograms.CtPar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CtPar( ; ns nt ds dt offset_s offset_t na orbit orbit_start)</code></pre><p>Constructor with named keywords. See <code>?CtGeom</code> for documentation.</p><pre><code class="language-julia-repl hljs">julia&gt; CtPar()
CtPar{Float32, Float32, CtSourceCircle} :
 ns::Int64 128
 nt::Int64 64
 ds::Float32 1.0
 dt::Float32 1.0
 offset_s::Float32 0.0
 offset_t::Float32 0.0
 na::Int64 60
 orbit::Float32 180.0
 orbit_start::Float32 0.0
 src::CtSourceCircle CtSourceCircle()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type3.jl#L190-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtSource" href="#Sinograms.CtSource"><code>Sinograms.CtSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CtSource</code></pre><p>Abstract type for representing X-ray CT source trajectories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/ct-source.jl#L14-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtSourceCircle" href="#Sinograms.CtSourceCircle"><code>Sinograms.CtSourceCircle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CtSourceCircle</code></pre><p>Type for representing circular X-ray CT source trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/ct-source.jl#L21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtSourceHelix" href="#Sinograms.CtSourceHelix"><code>Sinograms.CtSourceHelix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CtSourceHelix</code></pre><p>Type for representing helical X-ray CT source trajectories having constant pitch.</p><p><strong>Fields</strong></p><ul><li><code>pitch</code> helix pitch (unitless fraction of zFOV, default 0)</li><li><code>source_z0</code> initial z position of x-ray source (default 0) It should have same units as detector pixels etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/ct-source.jl#L28-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.CtSourceHelix-Tuple{}" href="#Sinograms.CtSourceHelix-Tuple{}"><code>Sinograms.CtSourceHelix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CtSourceHelix( ; pitch = 0, source_z0 = 0)</code></pre><p>Constructor with named keywords</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/ct-source.jl#L52-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.FBPNormalPlan" href="#Sinograms.FBPNormalPlan"><code>Sinograms.FBPNormalPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FBPNormalPlan{S,I,H,P}</code></pre><p>Struct type for storing &quot;normal&quot; FBP plan.</p><p>The <code>view_weight</code> can include (products of)</p><ul><li>Parker weighting for short scans</li><li>view-wise weighting from <code>fbp_sino_weight</code> todo</li><li><code>dβ</code> weighting for possibly nonuniform angles from <code>_angle_weights</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/plan2.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.FBPplan" href="#Sinograms.FBPplan"><code>Sinograms.FBPplan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FBPplan</code></pre><p>Abstract type for FBP plans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/plan2.jl#L8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.FDKplan" href="#Sinograms.FDKplan"><code>Sinograms.FDKplan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FDKplan{C,I,H,V}</code></pre><p>Struct type for storing FDK plan.</p><p>The <code>view_weight</code> can include (products of)</p><ul><li>Parker weighting for short scans</li><li>view-wise CBCT weighting from <code>fdk_weight_cyl</code></li><li><code>dβ</code> weighting for possibly nonuniform angles from <code>_angle_weights</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp3/plan3.jl#L10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.RayGeom" href="#Sinograms.RayGeom"><code>Sinograms.RayGeom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RayGeom{Td,To}</code></pre><p>Parent type for <code>SinoGeom</code> and <code>CtGeom</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/util.jl#L7-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.SinoFanArc" href="#Sinograms.SinoFanArc"><code>Sinograms.SinoFanArc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SinoFanArc{Td,To}</code></pre><p>2D fan-beam sinogram geometry for arc detector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type2.jl#L124-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.SinoFanArc-Tuple{Val{:ge1}}" href="#Sinograms.SinoFanArc-Tuple{Val{:ge1}}"><code>Sinograms.SinoFanArc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SinoFanArc(Val(:ge1) ; kwargs...)</code></pre><p>GE Lightspeed system CT geometry.</p><p><strong>option</strong></p><ul><li><code>unit::RealU = 1</code> or use <code>1mm</code></li><li><code>nb::Int = 888</code> # of detector channels</li><li><code>d::RealU = 1.0239</code> channel spacing</li><li><code>offset::Real = 1.25</code> for &quot;quarter-detector&quot; offset</li><li><code>na::Int = 984</code> # of angles</li><li><code>orbit::Union{Symbol,Real} = 360</code> use <code>:short</code> for short scan</li><li><code>dsd::RealU = 949.075</code></li><li><code>dod::RealU = 408.075</code></li></ul><p><strong>out</strong></p><ul><li><code>SinoFanArc</code></li></ul><p>These numbers are published in IEEE T-MI Oct. 2006, p.1272-1283 wang:06:pwl.</p><pre><code class="language-julia-repl hljs">julia&gt; SinoFanArc(Val(:ge1))
SinoFanArc{Float32, Float32} :
 nb::Int64 888
 d::Float32 1.0239
 offset::Float32 1.25
 na::Int64 984
 orbit::Float32 360.0
 orbit_start::Float32 0.0
 source_offset::Float32 0.0
 dsd::Float32 949.075
 dod::Float32 408.075</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type2.jl#L348-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.SinoFanArc-Tuple{}" href="#Sinograms.SinoFanArc-Tuple{}"><code>Sinograms.SinoFanArc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SinoFanArc( ; nb d offset na orbit orbit_start
    source_offset, dsd = 4 * nb * d, dod = nb * d)
SinoFanArc(:short ; ...)</code></pre><p>Constructor with named keywords. See <code>?SinoGeom</code> for documentation.</p><ul><li><p><code>d</code>, <code>source_offset</code>, <code>dsd</code>, <code>dod</code> must all have the same units.</p></li><li><p>Use <code>:short</code> argument to specify a short scan, in which case <code>na</code> will be scaled down proportionally as well.</p></li></ul><pre><code class="language-julia-repl hljs">julia&gt; SinoFanArc()
SinoFanArc{Float32, Float32} :
 nb::Int64 128
 d::Float32 1.0
 offset::Float32 0.0
 na::Int64 200
 orbit::Float32 360.0
 orbit_start::Float32 0.0
 source_offset::Float32 0.0
 dsd::Float32 512.0
 dod::Float32 128.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type2.jl#L231-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.SinoFanFlat" href="#Sinograms.SinoFanFlat"><code>Sinograms.SinoFanFlat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SinoFanFlat{Td,To}</code></pre><p>2D fan-beam sinogram geometry for flat detector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type2.jl#L143-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.SinoFanFlat-Tuple{}" href="#Sinograms.SinoFanFlat-Tuple{}"><code>Sinograms.SinoFanFlat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SinoFanFlat( ; nb d offset na orbit orbit_start
    source_offset, dsd= 4 * nb * d, dod = nb * d)
SinoFanFlat(:short ; ...)</code></pre><p>Constructor with named keywords. See <code>?SinoGeom</code> for documentation.</p><ul><li>Use <code>:short</code> argument to specify a short scan, in which case <code>na</code> will be scaled down proportionally as well.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; SinoFanFlat()
SinoFanFlat{Float32, Float32} :
 nb::Int64 128
 d::Float32 1.0
 offset::Float32 0.0
 na::Int64 200
 orbit::Float32 360.0
 orbit_start::Float32 0.0
 source_offset::Float32 0.0
 dsd::Float32 512.0
 dod::Float32 128.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type2.jl#L291-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.SinoGeom" href="#Sinograms.SinoGeom"><code>Sinograms.SinoGeom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SinoGeom{Td,To}</code></pre><p>Abstract type for representing ray geometries for 2D sinograms. This describes the sampling characteristics of a given sinogram for a 2D parallel or fan-beam system.</p><p><strong>Common fields</strong></p><ul><li><code>nb</code> # of &quot;radial&quot; samples, aka <code>nr</code> or <code>ns</code></li><li><code>d</code> aka <code>dr</code> or <code>ds</code>, &quot;radial&quot; sample spacing</li><li><code>offset</code> unitless sample offset (usually 0 or 0.25)</li><li><code>na</code> # of angular samples, aka <code>nϕ</code> or <code>nβ</code>  default: <code>2 * floor(Int, nb * π/2 / 2)</code></li><li><code>orbit</code> source orbit in degrees (or Unitful)</li><li><code>orbit_start</code> starting angle in degrees (or Unitful) <code>orbit</code> and <code>orbit_start</code> must both be unitless (degrees) or have same units.</li></ul><p><strong>Additional fields for <code>SinoFan</code> types</strong></p><ul><li><code>dsd</code> distance from source to detector</li><li><code>dod</code> distance from origin to detector</li><li><code>source_offset</code> usually 0</li></ul><p><strong>Units:</strong></p><ul><li><code>d</code>, <code>source_offset</code>, <code>dsd</code>, <code>dod</code> must all have the same units.</li></ul><p><strong>Basic methods</strong></p><ul><li><code>angles</code> (na) in degrees</li><li><code>dims (nb, na)</code></li><li><code>ones = ones(Float32, nb, na)</code></li><li><code>zeros = zeros(Float32, nb, na)</code></li><li><code>rays</code> iterator of <code>(r, ϕ)</code> parallel-beam coordinate tuples of size <code>(nb, na)</code></li><li><code>downsample(st, down)</code> reduce sampling by integer factor</li><li><code>oversample(st, over)</code></li><li><code>sino_geom_plot!</code> plot system geometry</li></ul><p><strong>Non-exported helper functions for developers:</strong></p><ul><li><code>_ds|dr</code> radial sample spacing (<code>NaN</code> for <code>:moj</code>)</li><li><code>_s (nb) s</code> sample locations</li><li><code>_w = (nb-1)/2 + offset</code> &quot;middle&quot; sample position</li><li><code>_ar (na)</code> source angles [radians]</li><li><code>_rfov</code> radial FOV</li><li><code>_xds (nb)</code> center of detector elements (beta=0)</li><li><code>_yds (nb)</code> &quot;&quot;</li><li><code>_tau(rg, x, y)</code> projected s/ds for each <code>(x,y)</code> pair <code>(length(x), na)</code></li><li><code>_shape(rg, sino [,:])</code> reshape <code>sino</code> into array <code>(nb,na[,:])</code></li><li><code>_unitv(rg [, (ib,ia)])</code> unit &#39;vector&#39; with single nonzero element</li></ul><p>For mojette:</p><ul><li><code>_d_ang (na)</code> angle-dependent radial spacing</li></ul><p>For fan beam:</p><ul><li><code>_dso = dsd - dod</code> distance from source to origin (Inf for parallel beam)</li><li><code>_dfs</code> distance from source to detector focal spot       (0 for 3rd gen CT, <code>Inf</code> for flat detectors)</li><li><code>_gamma(rg [,s]) (nb)</code> gamma sample values <code>radians</code>, optionally given <code>s</code> values</li><li><code>_gamma_max = max(|γ|)</code> half of fan angle <code>radians</code>, if <code>offset_s</code> == 0</li></ul><p><strong>Notes</strong></p><ul><li>Use <code>ct_geom()</code> instead for 3D axial or helical cone-beam CT.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type2.jl#L12-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.SinoMoj" href="#Sinograms.SinoMoj"><code>Sinograms.SinoMoj</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SinoMoj{Td,To}</code></pre><p>2D Mojette sinogram geometry where <code>d</code> means <code>dx</code> (square pixel size)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type2.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.SinoMoj-Tuple{}" href="#Sinograms.SinoMoj-Tuple{}"><code>Sinograms.SinoMoj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SinoMoj( ; nb d offset na orbit orbit_start)</code></pre><p>Constructor with named keywords. See <code>?SinoGeom</code> for documentation.</p><pre><code class="language-julia-repl hljs">julia&gt; SinoMoj()
SinoMoj{Float32, Float32} :
 nb::Int64 128
 d::Float32 1.0
 offset::Float32 0.0
 na::Int64 200
 orbit::Float32 180.0
 orbit_start::Float32 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type2.jl#L198-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.SinoPar" href="#Sinograms.SinoPar"><code>Sinograms.SinoPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SinoPar{Td,To}</code></pre><p>2D parallel-beam sinogram geometry</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type2.jl#L91-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.SinoPar-Tuple{}" href="#Sinograms.SinoPar-Tuple{}"><code>Sinograms.SinoPar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SinoPar( ; nb d offset na orbit orbit_start)</code></pre><p>Constructor with named keywords. See <code>?SinoGeom</code> for documentation.</p><pre><code class="language-julia-repl hljs">julia&gt; SinoPar()
SinoPar{Float32, Float32} :
 nb::Int64 128
 d::Float32 1.0
 offset::Float32 0.0
 na::Int64 200
 orbit::Float32 180.0
 orbit_start::Float32 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/type2.jl#L165-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.Window" href="#Sinograms.Window"><code>Sinograms.Window</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Window{S,T}</code></pre><p>Data type for FBP apodizing windows, with given window <code>shape::S</code> and <code>cutoff::T</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; Window(Hamming(), 0.8)
Window{Hamming, Float64}(Hamming(), 0.8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/window.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.WindowVect" href="#Sinograms.WindowVect"><code>Sinograms.WindowVect</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindowVect{V} &lt;: AbstractWindowShape</code></pre><p>A user-specified window vector, constructed via <code>WindowVect(v::V)</code>, where <code>v</code> is a <code>AbstractVector</code>. Caution: <code>length(v)</code> must be appropriate for the padded sinogram size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/window.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Sinograms.RayGeom}" href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Sinograms.RayGeom}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show(io::IO, ::MIME&quot;text/plain&quot;, rg::RayGeom)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/common.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms._angle_weights-Tuple{AbstractVector{&lt;:Number}}" href="#Sinograms._angle_weights-Tuple{AbstractVector{&lt;:Number}}"><code>Sinograms._angle_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_angle_weights(ar::AbstractVector{&lt;:RealU})</code></pre><p>Angular weighting to # scale projections by dβ (aka dϕ or da) for Riemann-like integration.</p><p><strong>input</strong></p><ul><li><code>ar (na,)</code> angles in radians.</li></ul><p><strong>output</strong></p><p>For now, simply the scalar <code>(ar[begin+1]-ar[begin]) / n180</code> where <code>n180</code> is the number of full multiples of 180°. This simplifies to <code>π/na</code> for typical 180° and 360° scans. For a fan-beam short scan (180° + fan angle), it also simplifies to <code>π/na</code>, where the &quot;excess&quot; is handled by Parker weighting.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rg = SinoPar(); Sinograms._angle_weights(Sinograms._ar(rg)), π/rg.na
(0.015707962f0, 0.015707963267948967)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; rg = SinoPar(;orbit=360); Sinograms._angle_weights(Sinograms._ar(rg)), π/rg.na
(0.015707962f0, 0.015707963267948967)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; rg = SinoFanArc(:short); Sinograms._angle_weights(Sinograms._ar(rg)), π/rg.na
(0.04842342f0, 0.04487989505128276)</code></pre><p>For now, only equally spaced views are supported, but this is where unequal spacing would be handled, and the output would be of size <code>(na,)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/d-angle.jl#L18-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms._gamma" href="#Sinograms._gamma"><code>Sinograms._gamma</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_gamma(rg::RayGeom [, s])</code></pre><p>Return gamma (γ: fan angle) values for fan-beam geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/common.jl#L75-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms._reale-Tuple{Any}" href="#Sinograms._reale-Tuple{Any}"><code>Sinograms._reale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_reale(x ; rtol = …)</code></pre><p>Return the real part of <code>x</code>, but warn if the imaginary part is too large. By default this uses a 100× larger <code>rtol</code> than <code>isapprox</code> due to FFT errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/reale.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms._rfov-Tuple{Union{CtPar, SinoPar}}" href="#Sinograms._rfov-Tuple{Union{CtPar, SinoPar}}"><code>Sinograms._rfov</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rfov(rg::RayGeom)</code></pre><p>Radial FOV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/common.jl#L43-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms._shape-Tuple{Sinograms.RayGeom, AbstractArray}" href="#Sinograms._shape-Tuple{Sinograms.RayGeom, AbstractArray}"><code>Sinograms._shape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_shape(rg, x::AbstractArray [, :])</code></pre><p>Reshape <code>x</code> to <code>dims(rg)</code> or <code>(dims(rg)..., :)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/common.jl#L90-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms._show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Any}" href="#Sinograms._show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Any}"><code>Sinograms._show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_show(io::IO, ::MIME&quot;text/plain&quot;, st::Any)</code></pre><p>Informative way to show fields of a struct (composite type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/util.jl#L23-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms._tau-Tuple{Sinograms.RayGeom, AbstractArray, AbstractArray}" href="#Sinograms._tau-Tuple{Sinograms.RayGeom, AbstractArray, AbstractArray}"><code>Sinograms._tau</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_tau(rg::RayGeom, x, y)</code></pre><p>Projected <code>s/ds</code>, useful for footprint center and support. Returns <code>Matrix</code> of size <code>length(x) × rg.na</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/tau.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms._unitv" href="#Sinograms._unitv"><code>Sinograms._unitv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_unitv([T=Float32], rg:RayGeom [, pos::Tuple])</code></pre><p>Projection views with a single non-zero ray value at position <code>pos</code> (default: middle).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/common.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms._xds-Tuple{Union{CtPar, SinoPar}}" href="#Sinograms._xds-Tuple{Union{CtPar, SinoPar}}"><code>Sinograms._xds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_xds(rg::RayGeom)</code></pre><p>Center <code>x</code> positions of detectors (for beta = 0), for central row of detector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/common.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms._yds-Union{Tuple{Union{CtPar{Td}, SinoPar{Td}}}, Tuple{Td}} where Td" href="#Sinograms._yds-Union{Tuple{Union{CtPar{Td}, SinoPar{Td}}}, Tuple{Td}} where Td"><code>Sinograms._yds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_yds(rg::RayGeom)</code></pre><p>Center <code>y</code> positions of detectors (for beta = 0), for central row of detector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/common.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.angles-Tuple{Sinograms.RayGeom}" href="#Sinograms.angles-Tuple{Sinograms.RayGeom}"><code>Sinograms.angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angles(rg::RayGeom) =</code></pre><p>Return vector of angles for this ray geometry, in whatever units the user used to specify <code>orbit</code> and <code>orbit_start</code>, typically degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/common.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.cb_arc_to_par-Union{Tuple{Ts}, Tuple{Ts, Number, Number, Number, Number}} where Ts&lt;:Number" href="#Sinograms.cb_arc_to_par-Union{Tuple{Ts}, Tuple{Ts, Number, Number, Number, Number}} where Ts&lt;:Number"><code>Sinograms.cb_arc_to_par</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">u, v, azim, polar = cb_arc_to_par(s, t, β, dso, dod)</code></pre><p>Convert from cone-beam arc (3rd gen CT) coordinates to parallel-beam coordinates.</p><p><strong>in</strong></p><ul><li><code>s,t</code> detector coordinates</li><li><code>β</code> X-ray source angle, measured counter-clockwise from y axis</li><li><code>dso,dsd</code> distances for the geometry</li></ul><p><strong>out</strong></p><ul><li><code>u,v</code> transaxial and axial parallel-beam detector coordinates</li><li><code>azim</code> ϕ transaxial or azimuthal angle (radians)</li><li><code>polar</code> θ polar angle (radians)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp3/cb_arc_to_par.jl#L7-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.cb_flat_to_par-NTuple{5, Number}" href="#Sinograms.cb_flat_to_par-NTuple{5, Number}"><code>Sinograms.cb_flat_to_par</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">u, v, azim, polar = cb_flat_to_par(s, t, β, dso, dod)</code></pre><p>Convert from cone-beam flat panel coordinages to parallel-beam coordinates.</p><p><strong>in</strong></p><ul><li><code>s,t</code> detector coordinates</li><li><code>β</code> X-ray source angle, measured counter-clockwise from y axis</li><li><code>dso,dsd</code> distances for the geometry</li></ul><p><strong>out</strong></p><ul><li><code>u,v</code> transaxial and axial parallel-beam detector coordinates</li><li><code>azim</code> ϕ transaxial or azimuthal angle (radians)</li><li><code>polar</code> θ polar angle (radians)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp3/cb_flat_to_par.jl#L7-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.cbct_back-Tuple{AbstractArray{&lt;:Number, 3}, CtFan, ImageGeoms.ImageGeom{3, S, M} where {S&lt;:Tuple{Number, Number, Number}, M&lt;:AbstractArray{Bool, 3}}}" href="#Sinograms.cbct_back-Tuple{AbstractArray{&lt;:Number, 3}, CtFan, ImageGeoms.ImageGeom{3, S, M} where {S&lt;:Tuple{Number, Number, Number}, M&lt;:AbstractArray{Bool, 3}}}"><code>Sinograms.cbct_back</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cbct_back(proj, rg, ig)</code></pre><p>Cone-beam backprojector for feldkamp.jl</p><p><strong>in</strong></p><ul><li><code>proj (ns,nt,na)</code> cone-beam projection views</li><li><code>rg::CtGeom</code></li><li><code>ig::ImageGeom</code></li></ul><p><strong>out</strong></p><ul><li><code>img (nx,ny,nz)</code> back-projection result</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp3/cbct-back.jl#L12-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.cbct_back_fan!-Union{Tuple{Toffset}, Tuple{T}, Tuple{Array{T, 3}, AbstractArray{&lt;:Number, 3}, AbstractVector{&lt;:Number}, Number, Number, Number, Number, Toffset, Toffset, Bool, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractArray{Bool, 3}}} where {T&lt;:Number, Toffset&lt;:Real}" href="#Sinograms.cbct_back_fan!-Union{Tuple{Toffset}, Tuple{T}, Tuple{Array{T, 3}, AbstractArray{&lt;:Number, 3}, AbstractVector{&lt;:Number}, Number, Number, Number, Number, Toffset, Toffset, Bool, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractArray{Bool, 3}}} where {T&lt;:Number, Toffset&lt;:Real}"><code>Sinograms.cbct_back_fan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cbct_back_fan!(...)</code></pre><p>This should work even for non-uniformly spaced source angles (for a circular source trajectory).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp3/cbct-back.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.ct_geom_plot2!-Tuple{CtGeom, ImageGeoms.ImageGeom}" href="#Sinograms.ct_geom_plot2!-Tuple{CtGeom, ImageGeoms.ImageGeom}"><code>Sinograms.ct_geom_plot2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ct_geom_plot2!(rg::CtGeom [, ig::ImageGeom])</code></pre><p>Plot central 2D portion of the CBCT geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp3/ct-plot.jl#L23-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.ct_geom_plot3-Tuple{CtFan, ImageGeoms.ImageGeom}" href="#Sinograms.ct_geom_plot3-Tuple{CtFan, ImageGeoms.ImageGeom}"><code>Sinograms.ct_geom_plot3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ct_geom_plot3(rg::CtFan [, ig::ImageGeom])</code></pre><p>3D CBCT geometry plot</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp3/ct-plot.jl#L64-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.downsample-Tuple{CtGeom, Int64}" href="#Sinograms.downsample-Tuple{CtGeom, Int64}"><code>Sinograms.downsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">downsample(rg, down::Int)
downsample(rg, down::NTuple{3,Int})</code></pre><p>Down-sample CT geometry (for testing with small problems).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/ct-geom.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.downsample-Union{Tuple{G}, Tuple{G, Int64}} where G&lt;:SinoParallel" href="#Sinograms.downsample-Union{Tuple{G}, Tuple{G, Int64}} where G&lt;:SinoParallel"><code>Sinograms.downsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">downsample(rg, down)</code></pre><p>Down-sample sinogram geometry (for testing with small problems).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/sino-geom.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp" href="#Sinograms.fbp"><code>Sinograms.fbp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fbp(plan, sino)</code></pre><p>Filtered back-projection (FBP) reconstruction.</p><p><strong>in</strong></p><ul><li><code>plan::FBPplan</code></li><li><code>sino::AbstractArray{&lt;:Number} (nb,na,...)</code> sinogram(s)</li></ul><p><strong>out</strong></p><ul><li><code>image::Matrix{&lt;:Number} (nx,ny,...)</code> reconstructed image(s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/fbp.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp!-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}" href="#Sinograms.fbp!-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}}"><code>Sinograms.fbp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbp!(image, sino ; orbit::Real = 180, kwargs...)</code></pre><p>FBP reconstruction from a parallel-beam sinogram of size <code>[nr × nϕ]</code>. Writes result into <code>image</code> matrix.</p><p><strong>Input</strong></p><ul><li><code>sino::AbstractMatrix</code></li></ul><p><strong>Options for <code>SinoPar</code> constructor</strong></p><ul><li><code>dr</code> : sinogram radial spacing; default 1</li><li><code>orbit</code> : angular range in degrees; default 180</li><li><code>orbit_start</code> : angular range in degrees; default 0</li></ul><p><strong>Options for <code>ImageGeom</code></strong></p><ul><li><code>dx</code>, <code>dy</code>, <code>deltas</code>, <code>offset_x</code>, <code>offset_y</code>, <code>offsets</code></li><li><code>rmax</code> maximum radius for mask</li></ul><p><strong>Options</strong></p><ul><li><code>kwargs</code> : passed to <code>plan_fbp</code></li></ul><p><strong>Output</strong></p><ul><li><code>image::AbstractMatrix</code> is mutated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/fbp-par.jl#L39-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp-Union{Tuple{AbstractMatrix{Ts}}, Tuple{Td}, Tuple{Ts}} where {Ts&lt;:Number, Td&lt;:Number}" href="#Sinograms.fbp-Union{Tuple{AbstractMatrix{Ts}}, Tuple{Td}, Tuple{Ts}} where {Ts&lt;:Number, Td&lt;:Number}"><code>Sinograms.fbp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbp(sino::AbstractMatrix ; kwargs...)</code></pre><p>FBP reconstruction from a parallel-beam sinogram of size <code>[nr × nϕ]</code>. Returns an image of size <code>[nx × ny]</code>.</p><p><strong>Options</strong></p><ul><li><code>nx</code> : default <code>nr</code></li><li><code>ny</code> : default <code>nx</code></li><li><code>kwargs</code> : passed to <code>fbp!</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/fbp-par.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_back" href="#Sinograms.fbp_back"><code>Sinograms.fbp_back</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">img = fbp_back(rg, ig, sino ; ia_skip)</code></pre><p>2D pixel-driven backprojection for FBP.</p><p><strong>in</strong></p><ul><li><code>rg::SinoGeom</code></li><li><code>ig::ImageGeom</code></li><li><code>sino::AbstractArray{&lt;:Number}</code> sinogram(s) (line integrals), usually ramp filtered</li></ul><p><strong>option</strong></p><ul><li><code>ia_skip::Int</code> downsample in angle to save time for quick tests (default: 1)</li></ul><p><strong>out</strong></p><ul><li><code>img::Array{&lt;:Number}</code> reconstructed image(s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/back-par.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_back_fan!-Union{Tuple{Toffset}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Number, Number, Number, Bool, Number, Toffset, AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}, AbstractMatrix{Bool}}} where {T&lt;:Number, Toffset&lt;:Real}" href="#Sinograms.fbp_back_fan!-Union{Tuple{Toffset}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Number, Number, Number, Bool, Number, Toffset, AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}, AbstractMatrix{Bool}}} where {T&lt;:Number, Toffset&lt;:Real}"><code>Sinograms.fbp_back_fan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbp_back_fan!(image, sino, sinβ, cosβ,
    dsd, dso, source_offset, is_arc,
    ds, offset, xc, yc, mask ; ia_skip)</code></pre><p>Mutating version of pixel-driven back-projection for a grid of <code>(xc,yc)</code> pixel center locations for sinogram <code>sino</code> from a fan-beam geometry. It uses <code>Threads</code>. It assumes the angles are equally spaced over <code>[0,π)</code>.</p><p><strong>in</strong></p><ul><li><code>sino::Matrix{&lt;:Number}</code> <code>(nb, na)</code> usually ramp-filtered</li><li><code>sinβ::Vector{&lt;:Real}</code> <code>(na)</code></li><li><code>cosβ::Vector{&lt;:Real}</code> <code>(na)</code></li><li><code>dsd,dso,source_offset::RealU</code> geometry</li><li><code>is_arc::Bool</code></li><li><code>ds::RealU</code> ray spacing</li><li><code>offset::Real</code> detector offset (usually 0)</li><li><code>xc::Vector{&lt;:RealU}</code> <code>(nx)</code> pixel centers</li><li><code>yc::Vector{&lt;:RealU}</code> <code>(ny)</code> pixel centers</li><li><code>mask::Matrix{Bool}</code> <code>(nx, ny)</code> which pixels to reconstruct</li></ul><p><strong>option</strong></p><ul><li><code>ia_skip::Int</code> default 1</li></ul><p><strong>out</strong></p><ul><li><code>image::Matrix</code> <code>(nx, ny)</code> matrix to be mutated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/back-fan.jl#L186-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_back_fan-Union{Tuple{Tc}, Tuple{Toffset}, Tuple{Tds}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, Number, Number, Number, Bool, Tds, Toffset, AbstractArray{Tc}, AbstractArray{Tc}, AbstractMatrix{Bool}}} where {Ts&lt;:Number, To&lt;:Number, Tds&lt;:Number, Toffset&lt;:Real, Tc&lt;:Number}" href="#Sinograms.fbp_back_fan-Union{Tuple{Tc}, Tuple{Toffset}, Tuple{Tds}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, Number, Number, Number, Bool, Tds, Toffset, AbstractArray{Tc}, AbstractArray{Tc}, AbstractMatrix{Bool}}} where {Ts&lt;:Number, To&lt;:Number, Tds&lt;:Number, Toffset&lt;:Real, Tc&lt;:Number}"><code>Sinograms.fbp_back_fan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbp_back_fan(sino, betas,
    dsd, dso, dfs, source_offset, is_arc,
    ds, offset, xc, yc, mask ; ia_skip, T)</code></pre><p>Pixel-driven back-projection for a grid of <code>(xc,yc)</code> pixel center locations for sinogram <code>sino</code> from a fan-beam geometry. It assumes the angles are equally spaced over <code>[0,π)</code>.</p><p><strong>in</strong></p><ul><li><code>sino::Matrix{&lt;:Number}</code> <code>(nb, na)</code> usually ramp-filtered</li><li><code>betas::Vector{&lt;:Real}</code> <code>(na)</code> in radians</li><li><code>dsd,dso,source_offset::RealU</code> geometry</li><li><code>is_arc::Bool</code> arc or flat?</li><li><code>ds::RealU</code> ray spacing</li><li><code>offset::Real</code> detector offset (usually 0)</li><li><code>xc::Vector{&lt;:RealU}</code> <code>(nx)</code> pixel centers</li><li><code>yc::Vector{&lt;:RealU}</code> <code>(ny)</code> pixel centers</li><li><code>mask::Matrix{Bool}</code> <code>(nx, ny)</code> which pixels to reconstruct</li></ul><p><strong>option</strong></p><ul><li><code>ia_skip::Int</code> default 1</li><li><code>T::Type{&lt;:Number}</code> usually same as <code>eltype(sino)</code></li></ul><p><strong>out</strong></p><ul><li><code>image::Matrix</code> <code>(nx, ny)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/back-fan.jl#L130-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_back_fan_xy-Union{Tuple{Tx}, Tuple{Tb}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, AbstractVector{To}, Real, Real, Real, Bool, Tb, Tx, Tx}} where {Ts&lt;:Number, To&lt;:Real, Tb&lt;:Real, Tx&lt;:Real}" href="#Sinograms.fbp_back_fan_xy-Union{Tuple{Tx}, Tuple{Tb}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, AbstractVector{To}, Real, Real, Real, Bool, Tb, Tx, Tx}} where {Ts&lt;:Number, To&lt;:Real, Tb&lt;:Real, Tx&lt;:Real}"><code>Sinograms.fbp_back_fan_xy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbp_back_fan_xy(sino, sinβ, cosβ,
    dsd_ds, dso_ds, source_offset_ds, is_arc,
    wb, x, y ; T)</code></pre><p>Pixel-driven back-projection for a single (x,y) location for sinogram <code>sino</code> from a fan-beam geometry. It assumes the angles are equally spaced over <code>[0,π)</code>.</p><p><strong>in</strong></p><ul><li><code>sino::Matrix{&lt;:Number}</code> <code>(nb, na)</code> usually ramp-filtered</li><li><code>sinβ::Vector{&lt;:Real}</code> <code>(na)</code></li><li><code>cosβ::Vector{&lt;:Real}</code> <code>(na)</code></li><li><code>dsd_ds,dso_ds,source_offset_ds::Real</code> geometry, normalized</li><li><code>wb::Real = (nb+1)/2 + offset</code> where usually <code>offset=0</code></li><li><code>x,y::Real</code> pixel center location, normalized by ray spacing</li></ul><p><strong>option</strong></p><ul><li><code>T::Type{&lt;:Number}</code> typically same as <code>eltype(sino)</code></li></ul><p><strong>out</strong></p><ul><li>Returns a scalar of type <code>T</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/back-fan.jl#L257-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_back_par!-Union{Tuple{Toffset}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Number, Toffset, AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}, AbstractMatrix{Bool}}} where {T&lt;:Number, Toffset&lt;:Real}" href="#Sinograms.fbp_back_par!-Union{Tuple{Toffset}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Number, Toffset, AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}, AbstractMatrix{Bool}}} where {T&lt;:Number, Toffset&lt;:Real}"><code>Sinograms.fbp_back_par!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbp_back_par!(image, sino, sinϕ, cosϕ,
    ds, offset, xc, yc, mask ; ia_skip)</code></pre><p>Mutating version of pixel-driven back-projection for a grid of <code>(xc,yc)</code> pixel center locations for sinogram <code>sino</code> from a parallel-beam geometry. It uses <code>Threads</code>. It assumes the angles are equally spaced over <code>[0,π)</code>.</p><p><strong>in</strong></p><ul><li><code>sino::Matrix{&lt;:Number}</code> <code>(nb, na)</code> usually ramp-filtered</li><li><code>sinϕ::Vector{&lt;:Real}</code> <code>(na)</code></li><li><code>cosϕ::Vector{&lt;:Real}</code> <code>(na)</code></li><li><code>ds::RealU</code> ray spacing</li><li><code>offset::Real</code> detector offset (usually 0)</li><li><code>xc::Vector{&lt;:RealU}</code> <code>(nx)</code> pixel centers</li><li><code>yc::Vector{&lt;:RealU}</code> <code>(ny)</code> pixel centers</li><li><code>mask::Matrix{Bool}</code> <code>(nx, ny)</code> which pixels to reconstruct</li></ul><p><strong>option</strong></p><ul><li><code>ia_skip::Int</code> default 1</li></ul><p><strong>out</strong></p><ul><li><code>image::Matrix</code> <code>(nx, ny)</code> matrix to be mutated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/back-par.jl#L180-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_back_par-Union{Tuple{Tc}, Tuple{Toffset}, Tuple{Tds}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, Tds, Toffset, AbstractArray{Tc}, AbstractArray{Tc}, AbstractMatrix{Bool}}} where {Ts&lt;:Number, To&lt;:Number, Tds&lt;:Number, Toffset&lt;:Real, Tc&lt;:Number}" href="#Sinograms.fbp_back_par-Union{Tuple{Tc}, Tuple{Toffset}, Tuple{Tds}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, Tds, Toffset, AbstractArray{Tc}, AbstractArray{Tc}, AbstractMatrix{Bool}}} where {Ts&lt;:Number, To&lt;:Number, Tds&lt;:Number, Toffset&lt;:Real, Tc&lt;:Number}"><code>Sinograms.fbp_back_par</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbp_back_par(sino, angles,
    ds, offset, xc, yc, mask ; ia_skip, T)</code></pre><p>Pixel-driven back-projection for a grid of <code>(xc,yc)</code> pixel center locations for sinogram <code>sino</code> from a parallel-beam geometry. It assumes the angles are equally spaced over <code>[0,π)</code>.</p><p><strong>in</strong></p><ul><li><code>sino::Matrix{&lt;:Number}</code> <code>(nb, na)</code> usually ramp-filtered</li><li><code>angles::Vector{&lt;:Real}</code> <code>(na)</code> in radians</li><li><code>ds::RealU</code> ray spacing</li><li><code>offset::Real</code> detector offset (usually 0)</li><li><code>xc::Vector{&lt;:RealU}</code> <code>(nx)</code> pixel centers</li><li><code>yc::Vector{&lt;:RealU}</code> <code>(ny)</code> pixel centers</li><li><code>mask::Matrix{Bool}</code> <code>(nx, ny)</code> which pixels to reconstruct</li></ul><p><strong>option</strong></p><ul><li><code>ia_skip::Int</code> default 1</li><li><code>T::Type{&lt;:Number}</code> usually same as <code>eltype(sino)</code></li></ul><p><strong>out</strong></p><ul><li><code>image::Matrix</code> <code>(nx, ny)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/back-par.jl#L133-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_back_par_xy-Union{Tuple{Tx}, Tuple{Tb}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, AbstractVector{To}, Tb, Tx, Tx}} where {Ts&lt;:Number, To&lt;:Real, Tb&lt;:Real, Tx&lt;:Real}" href="#Sinograms.fbp_back_par_xy-Union{Tuple{Tx}, Tuple{Tb}, Tuple{To}, Tuple{Ts}, Tuple{AbstractMatrix{Ts}, AbstractVector{To}, AbstractVector{To}, Tb, Tx, Tx}} where {Ts&lt;:Number, To&lt;:Real, Tb&lt;:Real, Tx&lt;:Real}"><code>Sinograms.fbp_back_par_xy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbp_back_par_xy(sino, sinϕ, cosϕ,
    wb, x, y ; T)</code></pre><p>Pixel-driven back-projection for a single (x,y) location for sinogram <code>sino</code> from a parallel-beam geometry. It assumes the angles are equally spaced over <code>[0,π)</code>.</p><p><strong>in</strong></p><ul><li><code>sino::Matrix{&lt;:Number}</code> <code>(nb, na)</code> usually ramp-filtered</li><li><code>sinϕ::Vector{&lt;:Real}</code> <code>(na)</code></li><li><code>cosϕ::Vector{&lt;:Real}</code> <code>(na)</code></li><li><code>wb::Real = (nb+1)/2 + offset</code> where usually <code>offset=0</code></li><li><code>x,y::Real</code> pixel center location, normalized by ray spacing</li></ul><p><strong>option</strong></p><ul><li><code>T::Type{&lt;:Number}</code> typically same as <code>eltype(sino)</code></li></ul><p><strong>out</strong></p><ul><li>Returns a scalar of type <code>T</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/back-par.jl#L256-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_filter-Union{Tuple{}, Tuple{Sinograms.RayGeom{Td}}, Tuple{Td}} where Td&lt;:Number" href="#Sinograms.fbp_filter-Union{Tuple{}, Tuple{Sinograms.RayGeom{Td}}, Tuple{Td}} where Td&lt;:Number"><code>Sinograms.fbp_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Hk = fbp_filter(rg::RayGeom ;
    npad=0, ds::RealU = rg.d, decon1::Bool=true, window=Window())</code></pre><p>Compute frequency response of ramp-like filter used for FBP image reconstruction. Supports parallel-beam and fan-beam tomographic geometries in 2D and 3D. This code samples the band-limited ramp to avoid the aliasing that would be caused by sampling the ramp directly in the frequency domain.</p><p><strong>in</strong></p><ul><li><code>rg::RayGeom</code></li></ul><p><strong>option</strong></p><ul><li><code>npad::Int</code> # of padded samples. (default: next power of 2)</li><li><code>ds::Td</code> detector sample spacing (default from <code>st</code>)</li><li><code>decon1::Bool</code> deconvolve effect of linear interpolator? (default: true)</li><li><code>window::Window</code> apodizer; default: <code>Window()</code></li></ul><p><strong>out</strong></p><ul><li><code>Hk::Vector</code> apodized ramp filter frequency response</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/filter.jl#L9-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_ramp" href="#Sinograms.fbp_ramp"><code>Sinograms.fbp_ramp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">h, n = fbp_ramp(rg::SinoGeom, N::Int)</code></pre><p>&#39;ramp-like&#39; filters for parallel-beam and fan-beam FBP reconstruction. This sampled band-limited approach avoids the aliasing that would be caused by sampling the ramp directly in the frequency domain.</p><p><strong>in</strong></p><ul><li><code>rg::SinoGeom</code></li><li><code>N::Int</code> : # of samples (must be even)</li></ul><p><strong>out</strong></p><ul><li><code>h::Vector{&lt;:RealU}</code> : samples of band-limited ramp filter</li><li><code>n::UnitRange{Int64}</code> : -(N÷2):(N÷2-1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/ramp.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_sino_filter-Union{Tuple{Ts}, Tuple{AbstractArray{Ts}, AbstractVector{&lt;:Number}}} where Ts&lt;:Number" href="#Sinograms.fbp_sino_filter-Union{Tuple{Ts}, Tuple{AbstractArray{Ts}, AbstractVector{&lt;:Number}}} where Ts&lt;:Number"><code>Sinograms.fbp_sino_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino = fbp_sino_filter(sino::Array, filter::Vector ; extra=0)</code></pre><p>Apply ramp-like filters to sinogram(s) for 2D FBP image reconstruction. Supports both parallel-beam and fan-beam tomographic geometries in 2D and 3D.</p><p><strong>in</strong></p><ul><li><code>sino::AbstractArray{&lt;:Number}</code> <code>[nb (L)]</code> sinograms</li><li><code>filter::AbstractVector</code> <code>(npad ≥ nb)</code> apodized ramp filter frequency response</li></ul><p><strong>option</strong></p><ul><li><code>extra::Int</code> # of extra sinogram radial samples to keep (default: 0)</li><li><code>npad::Int</code> # of padded samples. (default: next power of 2)</li></ul><p><strong>out</strong></p><ul><li><code>sino::AbstractArray</code> sinogram with filtered rows</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/filter.jl#L104-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_sino_weight-Tuple{SinoFan}" href="#Sinograms.fbp_sino_weight-Tuple{SinoFan}"><code>Sinograms.fbp_sino_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbp_sino_weight(rg::SinoFan)</code></pre><p>Return 1D sinogram weighting for first step of 2D fan-beam FBP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/sino-weight.jl#L8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fbp_window-Tuple{Window, Int64}" href="#Sinograms.fbp_window-Tuple{Window, Int64}"><code>Sinograms.fbp_window</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbp_window(w::Window, N::Int ; T = Float32)</code></pre><p>Create an apodizing window of length <code>N</code> and <code>fftshift</code> it.</p><pre><code class="language-julia-repl hljs">julia&gt; fbp_window(Window(Hamming()), 4)
4-element Vector{Float32}:
 1.0
 0.54
 0.0
 0.54</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/window.jl#L46-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fdk-Tuple{FDKplan, AbstractArray{&lt;:Number, 3}}" href="#Sinograms.fdk-Tuple{FDKplan, AbstractArray{&lt;:Number, 3}}"><code>Sinograms.fdk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">image = fdk(plan, proj)</code></pre><p>Reconstruct 3D image from cone-beam computed tomography (CBCT) data collected with a circular source trajectory via FDK method.</p><p><strong>in</strong></p><ul><li><code>plan::FDKplan</code></li><li><code>proj</code> (ns,nt,na) projection views</li></ul><p><strong>out</strong></p><ul><li><code>image</code> (nx,ny,nz) reconstructed image</li></ul><p>References: Feldkamp, Davis, Kress, JOSA-A, 1(6):612-9, June 1984.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp3/fdk.jl#L48-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fdk_weight_cyl" href="#Sinograms.fdk_weight_cyl"><code>Sinograms.fdk_weight_cyl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fdk_weight_cyl</code></pre><p>FDK projection weighting providing &quot;exact&quot; CBCT reconstruction for cylindrical-like objects that satisfy <span>$f(x,y,z) = f(x,y,0) ∀z$</span>. The output is a <code>(ns,nt)</code> matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp3/fdk.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.fft_filter" href="#Sinograms.fft_filter"><code>Sinograms.fft_filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fft_filter(data::Array, filter::Vector [, dim])</code></pre><p>Apply filter to selected dimensions of array <code>data</code> using FFT.</p><p><strong>in</strong></p><ul><li><code>data::AbstractArray{&lt;:Number} (n, (L))</code></li><li><code>filter::AbstractVector (n)</code> apodized ramp filter frequency response</li></ul><p><strong>option</strong></p><ul><li><code>dim</code> non-singleton dimensions of <code>filter</code> (typically <code>1</code>)</li></ul><p><strong>out</strong></p><ul><li><code>out::AbstractArray</code> data filtered along dimension <code>dim</code></li></ul><p>If the input data is real, so will be the output; this assumes <code>filter</code> frequency response has appropriate symmetry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/filter.jl#L59-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.footprint_size" href="#Sinograms.footprint_size"><code>Sinograms.footprint_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">footprint_size(st::Union{SinoGeom,CtGeom}, ig::ImageGeom)</code></pre><p>Unitless maximum footprint size (in detector pixels).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/sys2/footprint.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.oversample-Union{Tuple{G}, Tuple{G, Int64}} where G&lt;:CtParallel" href="#Sinograms.oversample-Union{Tuple{G}, Tuple{G, Int64}} where G&lt;:CtParallel"><code>Sinograms.oversample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oversample(rg, over::Int)</code></pre><p>Over-sample CT geometry in &quot;radial&quot; dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/ct-geom.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.oversample-Union{Tuple{G}, Tuple{G, Int64}} where G&lt;:SinoParallel" href="#Sinograms.oversample-Union{Tuple{G}, Tuple{G, Int64}} where G&lt;:SinoParallel"><code>Sinograms.oversample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oversample(rg, over::Int)</code></pre><p>Over-sample sinogram geometry in &quot;radial&quot; dimension. For Mojette sampling, it means that <code>d = dx/over</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/sino-geom.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.parker_weight" href="#Sinograms.parker_weight"><code>Sinograms.parker_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parker_weight(rg::SinoGeom, T = Float32)</code></pre><p>Compute Parker weighting for non-360° orbits. See http://doi.org/10.1118/1.595078. Returns <code>Matrix{T}</code> of size:</p><ul><li>(1,1) for <code>SinoPar</code> with typical 180 or 360 orbit</li><li>(1,na) for <code>SinoPar</code> with atypical orbit</li><li>(1,1) for <code>SinoFan</code> with typical 360 orbit</li><li>(ns,na) for <code>SinoFan</code> with typical 360 orbit</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/parker.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.parker_weight-Tuple{CtFan}" href="#Sinograms.parker_weight-Tuple{CtFan}"><code>Sinograms.parker_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parker_weight(rg::CtFan; T::Type{&lt;:AbstractFloat} = Float32, kwargs...)</code></pre><p>For 3D case, return <code>Array{T,3}</code> where size is</p><ul><li><code>(1,1,1)</code> typical fan case with 360° orbit</li><li><code>(ns,1,na)</code> atypical fan case including short scan</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/parker.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.plan_fbp-Tuple{CtGeom, ImageGeoms.ImageGeom}" href="#Sinograms.plan_fbp-Tuple{CtGeom, ImageGeoms.ImageGeom}"><code>Sinograms.plan_fbp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plan = plan_fbp(rg, ig; window=Window(), ...)</code></pre><p>Plan FDK 3D CBCT image reconstruction, with either flat or arc detector.</p><p>To use this method, you first call it with the CT geometry and image geometry. The routine returns the initialized <code>plan</code>. Thereafter, to to perform FDK reconstruction, call <code>fbp</code> with the <code>plan</code> (perhaps numerous times for the same geometry).</p><p><strong>in</strong></p><ul><li><code>rg::CtGeom</code></li><li><code>ig::ImageGeom</code> only reconstruct pixels within <code>ig.mask</code>.</li></ul><p><strong>option</strong></p><ul><li><code>window::Window</code> e.g., <code>Window(Hamming(), 0.8)</code>; default <code>Window()</code></li><li><code>npad::Int</code> # of radial bins after padding; default <code>nextpow(2, rg.ns + 1)</code></li><li><code>decon1::Bool</code> deconvolve interpolator effect? (default <code>true</code>)</li></ul><p><strong>out</strong></p><ul><li><code>plan::FDKplan</code> initialized plan</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp3/plan3.jl#L32-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.plan_fbp-Tuple{SinoGeom, ImageGeoms.ImageGeom}" href="#Sinograms.plan_fbp-Tuple{SinoGeom, ImageGeoms.ImageGeom}"><code>Sinograms.plan_fbp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plan = plan_fbp(rg, ig; how=:normal, window=Window())</code></pre><p>Plan FBP 2D tomographic image reconstruction for parallel-beam &amp; fan-beam cases, with either flat or arc detector for fan-beam case.</p><p>To use this method, you first call it with the sinogram geometry and image geometry. The routine returns the initialized <code>plan</code>. Thereafter, to to perform FBP reconstruction, call <code>fbp</code> with the <code>plan</code> (perhaps numerous times for the same geometry).</p><p><strong>in</strong></p><ul><li><code>rg::SinoGeom</code></li><li><code>ig::ImageGeom</code> only reconstruct pixels within <code>ig.mask</code>.</li></ul><p><strong>option</strong></p><ul><li><code>how::Symbol</code> how to reconstruct<ul><li><code>:normal</code> default</li><li><code>:mojette</code> use mojette rebinning and Gtomo2_table</li></ul></li><li><code>window::Window</code> e.g., <code>Window(Hamming(), 0.8)</code>; default <code>Window()</code></li><li><code>npad::Int</code> # of radial bins after padding; default <code>nextpow(2, rg.nb + 1)</code></li><li><code>decon1::Bool</code> deconvolve interpolator effect? (default <code>true</code>)</li><li><code>T::Type{&lt;:Number}</code> type of <code>sino</code> elements (default <code>Float32</code>)</li></ul><p><strong>out</strong></p><ul><li><code>plan::FBPplan</code> initialized plan</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/plan2.jl#L73-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.ramp_arc-Tuple{Int64, Number, Number}" href="#Sinograms.ramp_arc-Tuple{Int64, Number, Number}"><code>Sinograms.ramp_arc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(h, n) = ramp_arc(N::Int, ds::RealU, dsd::RealU)</code></pre><p>Ramp filter samples for arc fan geometry, for <code>n = -(N÷2):(N÷2-1)</code>.</p><ul><li><code>N</code> must be even.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/ramp.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.ramp_flat-Tuple{Int64, Number}" href="#Sinograms.ramp_flat-Tuple{Int64, Number}"><code>Sinograms.ramp_flat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(h, n) = ramp_flat(N::Int, ds::RealU)</code></pre><p>Ramp filter samples for flat fan geometry, for <code>n = -(N÷2):(N÷2-1)</code>.</p><ul><li><code>N</code> must be even.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp/ramp.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.rays-Tuple{CtPar}" href="#Sinograms.rays-Tuple{CtPar}"><code>Sinograms.rays</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i = rays(rg::CtGeom)</code></pre><p>Return parallel-beam coordinates of all rays for this CT geometry. Return type of <code>i</code> is a <code>ProductIterator</code> that makes tuples of the form <code>(u, v, ϕ, θ)</code>. To make projections call <code>p = [fun(c...) for c in i]</code> where <code>fun</code> is <code>radon(...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/ct-geom.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.rays-Tuple{SinoPar}" href="#Sinograms.rays-Tuple{SinoPar}"><code>Sinograms.rays</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i = rays(rg::SinoGeom)</code></pre><p>Radial <code>r</code> and angular <code>ϕ</code> coordinates (in radians) of all sinogram elements for the given geometry. Return type of <code>i</code> is a <code>ProductIterator</code> that makes tuples of the form <code>(r, ϕ)</code>. To make projections call <code>p = [fun(c...) for c in i]</code> where <code>fun</code> is <code>radon(...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/geom/sino-geom.jl#L88-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.sino_geom_plot!-Tuple{SinoGeom, ImageGeoms.ImageGeom}" href="#Sinograms.sino_geom_plot!-Tuple{SinoGeom, ImageGeoms.ImageGeom}"><code>Sinograms.sino_geom_plot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_plot!(rg, ig)</code></pre><p>Picture of the source position / detector geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/sino-plot.jl#L151-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.sino_geom_plot!-Tuple{SinoGeom}" href="#Sinograms.sino_geom_plot!-Tuple{SinoGeom}"><code>Sinograms.sino_geom_plot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_geom_plot!(rg)</code></pre><p>Picture of the source position / detector geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/sino-plot.jl#L116-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.sino_plot_rays-Tuple{SinoGeom}" href="#Sinograms.sino_plot_rays-Tuple{SinoGeom}"><code>Sinograms.sino_plot_rays</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sino_plot_rays(rg::SinoGeom ; kwargs...)</code></pre><p>Make a scatter plot of the <code>(r, ϕ)</code> sample locations for all rays. Requires <code>Plots</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/fbp2/sino-plot.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.to_radians-Union{Tuple{AbstractArray{&lt;:Unitful.Quantity{T}}}, Tuple{T}} where T&lt;:AbstractFloat" href="#Sinograms.to_radians-Union{Tuple{AbstractArray{&lt;:Unitful.Quantity{T}}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Sinograms.to_radians</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_radians(angles::AbstractArray{Unitful.Quantity})</code></pre><p>Convert <code>Unitful</code> quantity array to radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/units.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.to_radians-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#Sinograms.to_radians-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Sinograms.to_radians</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_radians(angles::AbstractArray{&lt;:AbstractFloat})</code></pre><p>When Unitful package not loaded, assume <code>angles</code> are in degrees and convert to radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/Sinograms.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sinograms.zwart_powell-Tuple{Real, Real}" href="#Sinograms.zwart_powell-Tuple{Real, Real}"><code>Sinograms.zwart_powell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output = zwart_powell(r, ϕ)</code></pre><p>Analytic 2D Radon transform value of Zwart-Powell box spline, for radial distance <code>r</code> (normalized by pixel size) and angle <code>ϕ</code> (in radians).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImageRecon/Sinograms.jl/blob/ed697de111248560c3b78ccf5519abe75fe734ff/src/sys2/zwart_powell.jl#L12-L16">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../generated/examples/01-tomography/">Tomography overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 31 December 2022 23:24">Saturday 31 December 2022</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
